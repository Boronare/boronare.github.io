<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()">
<script>

var myGamePiece;
var components = [];
var keyLeft=false;
var keyRight=false;
var keyShift=false;
var keySpcBar=false;
function startGame() {
    myGamePiece = new component(30, 30, "red", 10, 120);
	components.push(new component(0, 270, "#000", 480, 0));
	components.push(new component(0, 270, "#000", 0, 0));
	components.push(new component(480, 0, "#000", 0, 0));
	components.push(new component(480, 0, "#000", 0, 270));
	components.push(new component(30,30,'#000',200,240));
	components.push(new component(30,30,'#000',260,200));
    myGameArea.start();
}

var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = 480;
        this.canvas.height = 270;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.interval = setInterval(updateGameArea, 25);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, color, x, y) {
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
	this.r = ()=>{return this.x+this.width;}
	this.b = ()=>{return this.y+this.height;}
	this.ground=false;
    this.update = ()=>{
		this.speedX=Math.trunc(this.speedX/1.3);
		this.speedX+=keyLeft?-2:keyRight?2:0;
		if(!this.ground)this.speedY+=1;
		if(this.ground&&keySpcBar) this.speedY=-10;
		if(this.speedX!=0||this.speedY!=0){ 
			this.ground=false;
			for(i in components){
				o=components[i];
				preintersectX=this.r()>o.x&&this.x<o.r();
				preintersectY=this.b()>o.y&&this.y<o.b();
				if(preintersectY)ground=true;
				dir=(this.b()+this.speedY>o.y&&this.y<o.b())?1:this.y+this.speedY<o.b()&&this.b()>o.y?-1:0;
				if(preintersectY){
					if(this.r()+this.speedX>o.x&&this.x<o.r()) {this.speedX=o.x-this.r();}
					else if(this.x+this.speedX<o.r()&&this.r()>o.x) {this.speedX=o.r()-this.x;}
				}else if(!preintersectX){
					right=this.r()+this.speedX>o.x&&this.x<o.r()
					left=this.x+this.speedX<o.r()&&this.r()>o.x;
					if(this.b()+this.speedY>o.y&&this.y<o.b()) {
						if(right) {this.speedX=o.x-this.r(); this.speedY=o.y-this.b();this.ground=true;}
						else if(left) {this.speedX=o.r()-this.x; this.speedY=o.y-this.b();this.ground=true;}
					}
					else if(this.y+this.speedY<o.b()&&this.b()>o.y) {
						if(right) {this.speedX=o.x-this.r();  this.speedY=o.b()-this.y;}
						else if(left) {this.speedX=o.r()-this.x;  this.speedY=o.b()-this.y;}
					}
				}
				if(this.b()+this.speedY>o.y&&this.y<o.b()&&preintersectX) {this.speedY=o.y-this.b();this.ground=true;}
				else if(this.y+this.speedY<o.b()&&this.b()>o.y&&preintersectX) this.speedY=o.b()-this.y;
			}
			if(this.speedY>8) this.speedY=8;
			this.x+=this.speedX;
			this.y+=this.speedY;
			ctx=myGameArea.context;
			ctx.fillText("x:"+this.x+" y:"+this.y+" speedx:"+this.speedX+" speedy:"+this.speedY,10,10);
		}
	}
	this.draw = ()=>{
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
	}
	document.onkeydown=function(e){
		if(e.keyCode==37)//LeftKeyPressed
			keyLeft=true;
		else if(e.keyCode==39)//RightKeyPressed
			keyRight=true;
		else if(e.keyCode==32)//SpaceBarPressed
			keySpcBar=true;
		else if(e.keyCode==16)//Lshift pressed
			keyShift=true;
	}
	document.onkeyup=function(e){
		if(e.keyCode==37)//LeftKey released
			keyLeft=false;
		else if(e.keyCode==39)//RightKey released
			keyRight=false;
		else if(e.keyCode==32)//SpaceBar released
			keySpcBar=false;
		else if(e.keyCode==16)//Lshift released
			keyShift=false;
	}
}

function updateGameArea() {
    myGameArea.clear();
	myGamePiece.update();
    for(i in components) components[i].draw();
    myGamePiece.draw();
}
</script>
</body>
</html>
